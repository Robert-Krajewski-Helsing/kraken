{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#kraken-build","title":"kraken-build","text":"<p>Kraken is a task orchestration system. It sets itself apart from traditional build systems in that it does not try to replace good build tooling that already exists, but instead build on top of it and orchestrate the invokations of high-level tools like Cargo (Rust) and Poetry (Python).</p> <p>The primary goal of Kraken is to drastically accelerate the setup of new projects and benefit from the ability to roll out new features in the software development lifecycle at scale.</p> <p>Kraken is currently primarily used and developed at Helsing.</p>"},{"location":"#getting-started","title":"Getting started","text":"<p>Kraken is best invoked in your project using the Kraken wrapper CLI <code>krakenw</code>. It takes care of installing the same version of Kraken for your project in any environment. The recommended way to install the wrapper is with Pipx. You need to use Python 3.7 - 3.10 (3.11+ is currently not supported due to an upstream issue in Dill).</p> <pre><code>$ pipx install kraken-wrapper\n</code></pre> <p>Kraken's build scripts are called <code>.kraken.py</code> and are written in Python. For <code>krakenw</code> to know what to install for your project, you need to begin your script with a call to the <code>buildscript()</code> function. The <code>kraken-std</code> package provides the core buisiness logic.</p> <pre><code>from kraken.common import buildscript\nbuildscript(requirements=[\"kraken-std\"])\n</code></pre> <p>Subsequently, you can import from the <code>kraken.std</code> module to import the functionality you need to describe your project's build:</p> <pre><code>from kraken.std import python\npython.mypy()\npython.flake8()\n</code></pre>"},{"location":"#development","title":"Development","text":"<p>Kraken uses [Slap][] as the Python build backend. If you need a fresh installation of all Kraken components, without relying on Kraken, you can run the Slap CLI:</p> <pre><code>$ slap venv -ac\n$ slap install --link\n</code></pre>"},{"location":"#releases","title":"Releases","text":"<p>All packages in this repository are released under the same version number simultaneously. Regardless, we still follow to indicate the severity of changes, and packages in this repository are expected to be compatible with one another according to semantic versioning.</p> <p>A release must be created by a maintainer that has write access to the <code>develop</code> branch. The release process is automated usnig Slap.</p> <pre><code>$ slap release -tp &lt;patch|minor|major|x.y.z&gt;\n$ slap publish\n</code></pre>"},{"location":"core/","title":"Index","text":""},{"location":"core/#welcome-to-the-kraken-core-documentation","title":"Welcome to the <code>kraken-core</code> documentation!","text":"<p>Kraken is a task orchestration system with a focus on ease of configuration and flexibility. It's main objectives are to reduce boilerplate and configuration overhead in software projects and to model and abstract complex workflows in the software development lifecycle to allow developers to focus on what really matters.</p>"},{"location":"core/changelog/","title":"Changelog","text":"<pre><code>$ cd ../../kraken-core &amp;&amp; slap changelog format --all --markdown  # exited with return code 2\n/bin/sh: 1: cd: can't cd to ../../kraken-core\n</code></pre>"},{"location":"core/docs/api/","title":"Public API","text":"<p>The public API of <code>kraken-core</code> consists of all members that are importable from the <code>kraken.core.api</code> module.</p> kraken/core/api.py<pre><code>\"\"\"\nThis module exports the public API of the Kraken build system.\n\nUsers of Kraken should only import from this module.\n\"\"\"\n\nfrom kraken.core.address import Address\nfrom kraken.core.system.context import Context, ContextEvent\nfrom kraken.core.system.errors import BuildError, ProjectLoaderError\nfrom kraken.core.system.executor import Graph\nfrom kraken.core.system.graph import TaskGraph\nfrom kraken.core.system.project import Project\nfrom kraken.core.system.property import Property\nfrom kraken.core.system.task import (\n    BackgroundTask,\n    GroupTask,\n    Task,\n    TaskRelationship,\n    TaskSet,\n    TaskStatus,\n    TaskStatusType,\n    VoidTask,\n)\n\n__all__ = [\n    \"Address\",\n    \"BackgroundTask\",\n    \"BuildError\",\n    \"Context\",\n    \"ContextEvent\",\n    \"Graph\",\n    \"GroupTask\",\n    \"Project\",\n    \"ProjectLoaderError\",\n    \"Property\",\n    \"Task\",\n    \"TaskGraph\",\n    \"TaskRelationship\",\n    \"TaskSet\",\n    \"TaskStatus\",\n    \"TaskStatusType\",\n    \"VoidTask\",\n]\n</code></pre>"},{"location":"core/docs/project/","title":"Project","text":""},{"location":"core/docs/project/#api-documentation","title":"API Documentation","text":"<p>@pydoc kraken.core.project.Project</p>"},{"location":"core/docs/tasks/","title":"Tasks","text":""},{"location":"core/docs/tasks/#overview","title":"Overview","text":"<p>Kraken describes the build graph using tasks which can have relationships and properties. Tasks are described in code using a subclass of {@link pydoc:kraken.core.task.Task}.</p> hello_task.py<pre><code>from kraken.core import Property, Task\n\nclass HelloTask(Task):\n    subject: Property[str]\n\n    def execute(self) -&gt; None:\n        print(\"Hello,\", self.subject.get())\n</code></pre> <p>Relationships between tasks can be formed with three methods:</p> <ol> <li>Explicitly using {@pydoc kraken.core.task.Task.add_relationship}</li> <li>By connecting the property of one task to that of another (using {@pydoc kraken.core.property.Property.set} or,    more commonly, passing them to {@pydoc kraken.core.project.Project.do})</li> <li>Overriding {@pydoc kraken.core.Task.get_relationships} in the task subclass</li> </ol> <p>Info</p> <p>Unlike other build systems, Kraken doesn't really care about files and does not treat that as build targets. An analogy to understand what Kraken does is this: If you were to build a C++ project, you will still use CMake or any other C++ build tool, and Kraken may invoke that build tool for you among other things.</p> <p>Warning</p> <p>As a side effect of this, Kraken is currently not particularly good at not running a task that may actually not need to run another time because it would not perform any new work.</p>"},{"location":"core/docs/tasks/#task-outputs","title":"Task outputs","text":"<p>A task property can be marked as an output property. The task is then expected to populate its value in {@pydoc kraken.core.task.Task.execute} (or {@pydoc kraken.core.task.Task.prepare} if the task decides that it does not need to run).</p> zip_task.py<pre><code>from kraken.core import Property, Task\nfrom pathlib import Path\nfrom typing import Union\n\nclass ZipTask(Task):\n    files: Property[List[Path]]\n    output_file: Property[Path] = Property.output()\n\n    # ...\n</code></pre> <p>Outputs of a task can be queried and used as inputs by other tasks. For example, if you receive a task and you only know that it delivers some particular type of Python object as an \"output\", you can pick it up without knowing the exact property.</p> <pre><code>paths = task.get_outputs(Path)\n</code></pre> <p>More commonly, this is done through the {@pydoc kraken.core.project.Project} when a task factory is called which accepts a list of tasks to provide a particular output.</p> upload_task.py<pre><code>from kraken.core import Project\n\ndef upload_task(*, name: str, folder_url: str, dependencies: list[str], project: Project | None) -&gt; UploadTask:\n    project = project or Project.current()\n    return project.do(\n        name=name, \n        task_type=UploadTask,\n        files=project.resolve_tasks(dependencies).select(Path).supplier(),\n    )\n</code></pre> <p>There's a bit to unpack here.</p> <ol> <li>We use the <code>Project.current()</code> static method to retrieve the Kraken project that     is currently being evaluated unless an explicit project was specified.</li> <li>Then we use the <code>project.do()</code> method to create a new task of type <code>UploadTask</code> (which is defined     somewhere else, but not a component delivered by Kraken).</li> <li>The <code>UploadTask</code> has a property defined as <code>files: Property[Sequence[Path]]</code>, and we pass the <code>files=...</code>     keyword argument to populate it. As a value, we pass a \"supplier\" object which will return all the <code>Path</code>     objects in output properties of the specified <code>dependencies</code>.</li> </ol> <p>Important</p> <p>You must keep in mind that the project is evaluated in full before any task is executed. It is therefore important to model the connection between the outputs of one task and the inputs of another in a lazy fashion. We could not successfully use <code>list(project.resolve_tasks(dependencies).select(Path).all())</code> here because the output properties of the <code>dependencies</code> will not have been populated yet.</p>"},{"location":"core/docs/tasks/#api-documentation","title":"API Documentation","text":"<p>@pydoc kraken.core.task.Task</p>"},{"location":"core/synopsis/","title":"Synopsis","text":""},{"location":"core/synopsis/#kraken","title":"<code>kraken</code>","text":"$ kraken --help"},{"location":"core/synopsis/run/","title":"kraken run","text":"$ kraken run --help"},{"location":"core/synopsis/query/","title":"kraken query","text":"$ kraken query --help"},{"location":"core/synopsis/query/describe/","title":"kraken query describe","text":"$ kraken query describe --help"},{"location":"core/synopsis/query/env/","title":"kraken query env","text":"$ kraken query env --help"},{"location":"core/synopsis/query/ls/","title":"kraken query ls","text":"$ kraken query ls --help"},{"location":"core/synopsis/query/visualize/","title":"kraken query visualize","text":"$ kraken query visualize --help"},{"location":"std/","title":"Welcome to the <code>kraken-std</code> documentation!","text":"<p>The Kraken standard library.</p>"},{"location":"std/#development","title":"Development","text":""},{"location":"std/#integration-testing","title":"Integration testing","text":"<p>Integration tests are located in <code>src/tests/integration</code>. The following tools need to be available to run the integration tests:</p> <ul> <li>Cargo (to test Cargo building and publishing) The Cargo integration tests run against Artifactory and Cloudsmith and requires credentials to temporarily create a new Cargo repository (available in CI).</li> <li>Docker (used to setup services that we run integration tests against)</li> <li>Helm (to test Helm packaging and publishing)</li> <li>Poetry (to test Python publishing and installing)</li> <li>Slap (to test Python publishing and installing)</li> </ul> <p>Test a single integration test</p> <pre><code>PYTEST_FLAGS=\"--log-cli-level DEBUG -s -k &lt;test_filter&gt;\" kraken run pytestIntegration -v\n</code></pre> <p>The integration tests create temporary files that need to be mounted into a Docker container. If you are running the integration tests in a Coder workspace, you may need to set <code>TMPDIR=$HOME/tmp</code> as the workspaces often only share the home volume with the Docker-in-Docker container.</p>"},{"location":"std/#pull-requests","title":"Pull Requests","text":"<p>By default, Pull Requests require a changelog entry to be added via the <code>slap changelog add</code> command. If no changelog entry was added, CI will fail. Some changes are not relevant to consumers of the API that they do not need to be recorded in the changelog, such as typos in the README. In such cases, the <code>no changelog</code> label can be added to the Pull Request.</p>"},{"location":"std/cargo/","title":"Cargo","text":"<p>Build Rust projects with Cargo.</p> <p>Features</p> <ul> <li>Supports private Crate registries by injecting Basic-auth credentials using a HTTPS proxy.</li> </ul> <p>Quickstart</p> <pre><code># ::requirements kraken-std\n\nfrom kraken.std.cargo import *\n\ncargo_registry( \n    \"artifactory\",\n    \"https://example.jfrog.io/artifactory/git/test-cargo.git\",\n    publish_token=f\"Bearer &lt;TOKEN&gt;\",\n    read_credentials=(\"me@example.org\", \"&lt;TOKEN&gt;\"),\n)\ncargo_auth_proxy()\ncargo_sync_config()\ncargo_build(\"debug\")\ncargo_build(\"release\")\ncargo_publish(\"artifactory\")\n</code></pre> <p>Integration tests</p> <p>The <code>cargo_publish()</code> and <code>cargo_build()</code> tasks are continuously integration tested against JFrog Artifactory and Cloudsmith.</p> <p>Build graph</p> <p></p>"},{"location":"std/cargo/#api-documentation","title":"API Documentation","text":"<p>@pydoc kraken.std.cargo.cargo_registry @pydoc kraken.std.cargo.cargo_auth_proxy @pydoc kraken.std.cargo.cargo_sync_config @pydoc kraken.std.cargo.cargo_fmt @pydoc kraken.std.cargo.cargo_build @pydoc kraken.std.cargo.cargo_publish @pydoc kraken.std.cargo.cargo_update @pydoc kraken.std.cargo.cargo_deny</p>"},{"location":"std/cargo/#environment-variables","title":"Environment variables","text":"<ul> <li><code>PROXY_PY_TIMEOUT</code></li> <li><code>KRAKEN_CARGO_BUILD_FLAGS</code></li> </ul>"},{"location":"std/changelog/","title":"Changelog","text":"<pre><code>$ cd ../../kraken-std &amp;&amp; slap changelog format --all --markdown  # exited with return code 2\n/bin/sh: 1: cd: can't cd to ../../kraken-std\n</code></pre>"},{"location":"std/docker/","title":"Docker","text":"<p>Build and publish Docker images.</p> <p>Supported backends</p> <ul> <li> Native Docker (currently does not perform auth for you)</li> <li> Buildx (currently does not perform auth for you)</li> <li> Kaniko</li> </ul> <p>Quickstart</p> <pre><code># .kraken.py\nfrom kraken.std.docker import build_docker_image\n\nbuild_docker_image(\n    name=\"buildDocker\",\n    dockerfile=\"docker/release.Dockerfile\",\n    tags=[\"kraken-example\"],\n    load=True,\n)\n</code></pre> <p>Integration tests</p> <p>The <code>build_docker_image()</code> function for Buildx and Kaniko are continuously integration tested to ensure that build time secrets under <code>/run/secrets</code> don't appear in the final image.</p>"},{"location":"std/docker/#api-documentation","title":"API Documentation","text":"<p>@pydoc kraken.std.docker.build_docker_image</p> <p>@pydoc kraken.std.docker.DockerBuildTask</p>"},{"location":"std/docker/#native","title":"Native","text":"<p>@pydoc kraken.std.docker.native.NativeBuildTask</p>"},{"location":"std/docker/#buildx","title":"Buildx","text":"<p>@pydoc kraken.std.docker.buildx.BuildxBuildTask</p>"},{"location":"std/docker/#kaniko","title":"Kaniko","text":"<p>@pydoc kraken.std.docker.kaniko.KanikoBuildTask</p>"},{"location":"std/docker/#manifest-tool","title":"Manifest Tool","text":"<p>@pydoc kraken.std.docker.manifest_tool.ManifestToolPushTask</p>"},{"location":"std/helm/","title":"Helm","text":"<p>Package and publish Helm charts to OCI or HTTP(S) registries.</p> <p>Quickstart</p> <pre><code># .kraken.py\nfrom kraken.core.api import Project\nfrom kraken.std.helm import HelmPushTask, HelmPackageTask, helm_settings\n\nhelm_settings().add_auth(\"example.jfrog.io\", \"me@example.org\", \"api_token\")\n\nproject = Project.current()\npackage = project.do(\"helmPackage\", HelmPackageTask, chart_path=\"./my-helm-chart\")\nproject.do(\"helmPush\", HelmPushTask, chart_tarball=package.chart_tarball, registry=\"example.jfrog.io/helm-local\")\n</code></pre>"},{"location":"std/helm/#api-documentation","title":"API Documentation","text":"<p>@pydoc kraken.std.helm.HelmSettings</p> <p>@pydoc kraken.std.helm.helm_settings</p> <p>@pydoc kraken.std.helm.HelmPackageTask</p> <p>@pydoc kraken.std.helm.HelmPushTask</p>"},{"location":"std/protobuf/","title":"Protobuf","text":"<p>Format and lint Proto files using buf.</p> <p>Quickstart</p> <pre><code># .kraken.py\nfrom kraken.core.api import Project\nfrom kraken.std.protobuf import BufFormatTask, BufLintTask\n\n\nproject = Project.current()\nproject.do(name, BufLintTask, group=\"lint\", **kwargs)\nproject.do(name, BufFormatTask, group=\"fmt\", **kwargs)\n</code></pre>"},{"location":"std/protobuf/#requirements","title":"Requirements","text":"<ul> <li>The buf lint task will only succeed when executed in a <code>/proto</code> directory</li> <li>The buf format task can be executed in the root of the project directory and will format inplace all of the proto files that exist in the repo </li> </ul>"},{"location":"std/protobuf/#api-documentation","title":"API Documentation","text":"<p>@pydoc kraken.std.protobuf.buf_format</p> <p>@pydoc kraken.std.protobuf.buf_lint</p> <p>@pydoc kraken.std.protobuf.BufFormatTask</p> <p>@pydoc kraken.std.protobuf.BufLintTask</p>"},{"location":"std/python/","title":"Python","text":"<p>Lint, format and test Python code.</p> <p>Supported tools</p> <ul> <li>Black</li> <li>Flake8</li> <li>isort</li> <li>Mypy</li> <li>Pycln</li> <li>Pylint</li> <li>Pytest</li> <li>Pyupgrade</li> </ul> <p>Supported build systems (for installing/building)</p> <ul> <li>Poetry</li> <li>Slap</li> </ul>"},{"location":"std/python/#build-systems","title":"Build systems","text":"<p>A build system that is supported by Kraken is needed to use the {@link pydoc:kraken.std.python.tasks.build_task.BuildTask}. Most build systems will support managed Python environments for the current Python project (e.g. <code>poetry install</code> will create a virtual environment and install the project into it).</p> <p>Build systems implemented for Kraken will take care of the installation, ensuring that the Python package indexes registered in the build script are made available to the installation process.</p>"},{"location":"std/python/#poetry","title":"Poetry","text":"<ul> <li>Package index credentials: The installation process injects package index configurations into <code>poetry.toml</code> and <code>pyproject.toml</code></li> <li>[TODO] Should we permanently inject the config into <code>pyproject.toml</code> and keep it in sync with a task?</li> </ul>"},{"location":"std/python/#slap","title":"Slap","text":"<ul> <li>Package index credentials: [TODO] The installation processs passes the extra index URLs to <code>slap install</code> using the <code>--package-index</code> option.</li> <li>[TODO] Should we add an option to permanently add a package index to the Slap configuration and then keep it in     sync with a task?</li> </ul>"},{"location":"std/python/#publishing","title":"Publishing","text":"<p>Independent of the Python build system used, Kraken will use Twine to publish to a Package index.</p>"},{"location":"std/python/#api-documentation","title":"API Documentation","text":"<p>@pydoc kraken.std.python.settings.python_settings</p> <p>@pydoc kraken.std.python.settings.PythonSettings</p>"},{"location":"std/python/#info","title":"Info","text":"<p>@pydoc kraken.std.python.tasks.InfoTask</p> <p>@pydoc kraken.sts.python.tasks.info</p>"},{"location":"std/python/#black","title":"Black","text":"<p>@pydoc kraken.std.python.tasks.black.BlackTask</p> <p>@pydoc kraken.std.python.tasks.black.black</p>"},{"location":"std/python/#flake8","title":"Flake8","text":"<p>@pydoc kraken.std.python.tasks.flake8.Flake8Task</p> <p>@pydoc kraken.std.python.tasks.flake8.flake8</p>"},{"location":"std/python/#isort","title":"isort","text":"<p>@pydoc kraken.std.python.tasks.isort.IsortTask</p> <p>@pydoc kraken.std.python.tasks.isort.isort</p>"},{"location":"std/python/#mypy","title":"Mypy","text":"<p>@pydoc kraken.std.python.tasks.mypy.MypyTask</p> <p>@pydoc kraken.std.python.tasks.mypy.mypy</p>"},{"location":"std/python/#stubtest","title":"Stubtest","text":"<p>@pydoc kraken.std.python.tasks.mypy_stubtest.MypyStubtestTask</p> <p>@pydoc kraken.std.python.tasks.mypy_stubtest.mypy_stubtest</p>"},{"location":"std/python/#pycln","title":"Pycln","text":"<p>@pydoc kraken.std.python.tasks.pycln.PyclnTask</p> <p>@pydoc kraken.std.python.tasks.pycln.pycln</p>"},{"location":"std/python/#pylint","title":"Pylint","text":"<p>@pydoc kraken.std.python.tasks.pylint.PylintTask</p> <p>@pydoc kraken.std.python.tasks.pylint.pylint</p>"},{"location":"std/python/#pytest","title":"Pytest","text":"<p>@pydoc kraken.std.python.tasks.pytest.PytestTask</p> <p>@pydoc kraken.std.python.tasks.pytest.pytest</p>"},{"location":"std/python/#pyupgrade","title":"Pyupgrade","text":"<p>@pydoc kraken.std.python.tasks.pyupgrade.PyUpgradeTask</p> <p>@pydoc kraken.std.python.tasks.pyupgrade.PyUpgradeCheckTask</p> <p>@pydoc kraken.std.python.tasks.pyupgrade.pyupgrade</p> <p>Environment variables</p> <ul> <li><code>PYTEST_FLAGS</code></li> </ul>"}]}